name: eks_deploy

on:
  workflow_call:

jobs:
  eks_deploy:
    runs-on: ubuntu-latest
    steps:

      - uses: dopplerhq/cli-action@v2

      # Github actions doppler secrets set to env for main
      - name: Login in Doppler, set Doppler env from github action project
        if: endsWith(github.ref, '/main')
        run: |
          doppler secrets download --no-file --format=docker >> $GITHUB_ENV;
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN_PRD }}

      # Service doppler secrets set to env for main
      - name: Login in Doppler, set Doppler env from service project
        if: endsWith(github.ref, '/main')
        run: |
          doppler secrets download --no-file --format=docker >> $GITHUB_ENV;
        env:
          DOPPLER_TOKEN: ${{ secrets.SERVICE_DOPPLER_TOKEN_PRD }}


      # Github actions doppler secrets set to env for develop
      - name: Login in Doppler, set Doppler env from github action project
        if: endsWith(github.ref, '/develop')
        run: |
          doppler secrets download --no-file --format=docker >> $GITHUB_ENV;
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN_DEV }}

      # Service doppler secrets set to env for develop
      - name: Login in Doppler, set Doppler env from service project
        if: endsWith(github.ref, '/develop')
        run: |
          doppler secrets download --no-file --format=docker >> $GITHUB_ENV;
        env:
          DOPPLER_TOKEN: ${{ secrets.SERVICE_DOPPLER_TOKEN_PRD }}

      - name: Test Doppler 2 envs
        id: test_doppler
        shell: bash
        run: |
          echo "AVAR::Service is:  ${{ secrets.SERVICE_NAME }}"
          echo "AVAR::Service DEMO_SECRET is:  ${{ env.DEMO_SECRET }}" 
      
      # We have one AWS account for github ci, and there is no differentiation based on env type dev or prd
      # - name: AWS Credentials
      #   uses: aws-actions/configure-aws-credentials@v1
      #   with:
      #     aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
      #     aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
      #     aws-region: ${{ env.AWS_REGION }}
      #     role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}


      # - name: Extract branch short sha
      #   id: git_extract_branch_sha
      #   shell: bash
      #   run: |
      #     echo "REPO_SHA_SHORT=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
      #     echo "Output for sha_short is: ${{ steps.git_extract_branch_sha.outputs.REPO_SHA_SHORT }}"

      # - name: kubeconfing
      #   id: kubeconfig
      #   run: |
      #     aws eks update-kubeconfig --name ${{ env.AWS_EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
      #     echo "KUBE_CONFIG_DATA=$(cat ~/.kube/config | base64)" >> $GITHUB_OUTPUT
          
      #     # TODO: We need to check if we can use RBAC to allow access this
      #     # echo "KUBE_HOSTNAME=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o json | jq -r '.status.loadBalancer.ingress[0].hostname')" >> $GITHUB_OUTPUT

      # - name: Create subdomain if service has that settings under Doppler
      #   id: create_subdomain
      #   if: ${{ success() && secrets.SERVICE_SUBDOMAIN != '' }}
      #   run: |
      #     echo "Creating subdomain ${{ secrets.SERVICE_SUBDOMAIN }} for service ${{ secrets.SERVICE_NAME }} under Cloudflare "
      #     output=$(python cf-utils.py)
      #     echo "SUBDOMAIN_URL=$(echo -n $output)" >> $GITHUB_OUTPUT
      #     echo "Subdomain for service ${{ secrets.SERVICE_NAME }} created."
      #   env:
      #     CF_TOKEN: ${{ env.CF_TOKEN }}
      #     CF_EMAIL: ${{ env.CF_EMAIL }}
      #     CF_DOMAIN: ${{ env.CF_DOMAIN }}
      #     SUBDOMAIN: ${{ secrets.SERVICE_SUBDOMAIN }}
      #     IP: ${{ steps.kubeconfig.outputs.KUBE_HOSTNAME }}

      # - name: Deploy ${{ secrets.SERVICE_NAME }} to kubernetes namespace ${{ env.AWS_EKS_NAMESPACE }}
      #   id: eksdeploy
      #   if: ${{ success() && env.AWS_EKS_NAMESPACE != '' &&  secrets.SERVICE_NAME != '' }}
      #   uses: koslib/helm-eks-action@v1.26.0
      #   env:
      #     KUBE_CONFIG_DATA: ${{ steps.kubeconfig.outputs.KUBE_CONFIG_DATA }}
      #   with:
      #     command: helm upgrade ${{ secrets.SERVICE_NAME }} ./helm --install --wait --atomic --namespace=${{ env.AWS_EKS_NAMESPACE }} --create-namespace --set "autoscaling.maxReplicas=${{ env.SERVICE_MAX_REPLICA || 1 }},imageCredentials.username=${{ env.DOCKERHUB_USERNAME }},imageCredentials.password=${{ env.DOCKERHUB_TOKEN }},dopplerToken=${{ env.SERVICE_DOPPLER_TOKEN }}" --set "image.repository=${{ env.DOCKERHUB_USERNAME }}/${{ secrets.SERVICE_NAME }}" --set "image.tag=${{ ${{ steps.git_extract_branch_sha.outputs.REPO_SHA_SHORT }} }}"
